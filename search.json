[{"title":"开发规范","url":"/posts/b52f0648/","content":"\n[Notion原文](https://www.notion.so/C-c82562c7bc354d8780c2ed6269f17edf)\n\n# 命名规范\n\n### 1、命名空间\n\n- 规则\n    1. 使用**Pascal规则，且首字符大写**\n    2. 尽量反映其内容所提供的的整体功能\n    3. 存在版本号时放在命名空间名称结尾，以“`V`”开头，如：V2_1_1\n    4. 按项目代号.框架层.模块1...模块n.<版本号>顺序\n- 例\n\n    ```csharp\n    namespace JW.Buss.Interface.Content.Artical.Entities.V2_7 {\n        /// <summary>\n        ///\n        /// </summary>\n        public class ArticalEntity {\n        }\n    }\n    ```\n\n### 2、类\n\n- 规则\n    1. 使用Pascal规则命名类名，首字母大写\n    2. 使用能够反映类功能的名词或名词短语命名类\n    3. 不要使用“`I`”、“`C`”、“`_`”等特点含义前\n    4. 文件名要能反映类的内容，最好是和类同名\n    5. 自定义异常类应以“`Exception`”结尾\n    6. 自定义特性应以“`Attribute`”结尾\n    7. 数据实体应以“`Entity`”结尾\n    8. 数据映射/输出应以“`Dto`”结尾\n    9. AutoMapper映射规则类应以“`Profile`”结尾\n- 例\n\n    ```csharp\n    public class Test {}\n    public class TestEntity {}\n    public class TestAttribute {}\n    public class TestExecption {}\n    public class TestDto {}\n    public class TestProfile\n    ```\n\n### 3、类字段（类成员）\n\n- 规则\n    1. 使用**Camel**规则命名，即首单词（或单词缩写）小写。\n    2. 类字段前可加“`_`”前缀\n    3. 禁止在普通变量前加“`m_`”（VC老命名规则）\n- 例\n\n    ```csharp\n    public class Test {\n    \tprivate string name;\n    \tprivate string _name;\n    \tprivate string myFavorite;\n    }\n    ```\n\n### 4、属性\n\n- 规则\n    1. 使用名词定义属性\n    2. 使用**Pascal**规则\n- 例\n\n    ```csharp\n    public class Test {\n    \tpublic string Name { get; set; }\n    }\n    ```\n\n### 5、常量\n\n- 规则\n    1. 只读常量使用**Pascal**命名规则\n    2. 枚举名使用**Pascal**命名规则\n    3. 枚举值从小到大顺序定义\n    4. 静态字段或属性才有**Pascal**\n- 例\n\n    ```csharp\n    public class Test {\n    \tpublic const string Name = \"JW.Quartz.Message.User\";\n    \tprivate readonly double Pi = 3.14159365753\n    }\n    ```\n\n### 6、参数\n\n- 规则\n    1. 采用**camel**命名规则\n    2. 使用描述性参数名称，参数名称应当具有最够的说明性\n    3. 检查方法所有输入参数的有效性\n- 例\n\n    ```csharp\n    public class Test {\n    \tpublic void Get(string name,string favorite) {\n    \t\n    \t}\n    }\n    ```\n\n### 7、接口\n\n- 规则\n    1. 采用**Pascal**规则，且必须以大写“`I`”开头\n    2. 接口名称要有意义，中间不能有下划线“`_`”等字符\n    3. 如果类实现了接口，名称尽量和接口相同，只是省掉“`I`”字符\n- 例\n\n    ```csharp\n    public interface ITest {}\n    interface IExample {}\n    ```\n\n### 8、方法\n\n- 规则\n    1. 采用**Pascal**命名规则\n    2. 方法名应使用动词或动词短语\n    3. 异步方法名应以“`Async`”结尾\n    4. 类中访问修饰符或功能相同的方法应该放在一起，且公共或实现接口的方法在前\n- 例\n\n    ```csharp\n    public class Test {\n    \tpublic void Create(string name,string favorite) {}\n    \tpublic Task CreateAsync(string name,string favorite) {}\n    \tprivate void Get() {}\n    }\n    ```\n\n### 9、事件\n\n- 规则\n    1. 委托名称采用**Pascal**命名规则\n    2. 定义事件的委托要是用EventHandle后缀，且包括`sender`和`e`两个参数\n    3. 事件用到的参数，名称要带有“`EnentArgs`”后缀\n- 例\n\n    ```csharp\n    public delegate void DoTask();\n    public class Test {\n    \tpublic event DoTask DoTaskEventHandle(Object sender,EventArgs e) {}\n    \tpublic event DoTask DoTaskEventHandle2(string strEventArgs) {}\n    }\n    ```\n\n### 10、路由\n\n- 规则\n    1. 采用**Pascal**命名规则\n    2. 路由层级必须“api/[controller]/[模块1]..../[模块n]/[名词]/[动词]/[路由参数]”\n    3. 动词可省略\n- 例\n\n    ```csharp\n    [Route(\"api/[controller]\")]\n    public class TestController {\n    \t[HttpPost(\"Example/Create\")]\n    \tpublic Task<IActionResult> CreateAsync(TestEntity entity) {}\n    \t[HttpGet(\"Example/{id}\")]\n    \t// [HttpGet(\"Example\")]\n    \tpublic Task<IActionResult> GetExampleById(int id) {}\n    }\n    ```\n\n### 11、业务多版本并存\n\n- 规则\n    1. 使用版本文件夹，第一个版本可不使用\n    2. 命名空间以版本结尾\n    3. 多版本的类名、接口名等都相同\n    4. 一般情况下不存在不同版本之间的混合引用，存在以命名空间区分\n- 例\n\n    ```csharp\n    // 默认，1.0\n    // 文件夹：Test\n    namespace JW.Buss.Interface.Test {\n    \tpublic interface ITestService {}\n    }\n    // 文件夹：Test\n    namespace JW.Buss.Service.Test {\n    \tpublic class TestService : ITestService {}\n    }\n    // 文件夹：Controller/Test\n    namespace Api.Test {\n    \tusing JW.Buss.Interface.Test;\n    \t[Route(\"api/[controller]\")]\n    \t// [ApiVersion(\"1.0\")]\n    \tpublic class TestController {\n    \t\tprivate readonly ITestService _testService;\n    \t\tpublic TestController(ITestService testService) {\n    \t\t\t_testService= testService;\n    \t\t}\n    \t}\n    }\n\n    // 2.0\n    // 文件夹：Test/V2.0\n    namespace JW.Buss.Interface.Test.V2_0 {\n    \tpublic interface ITestService {}\n    }\n    // 文件夹：Test/V2.0\n    namespace JW.Buss.Service.Test.V2_0 {\n    \tusing JW.Buss.Interface.Test.V2_0;\n    \t// public class TestService : Interface.Test.V2_0.ITestService {}\n    \tpublic class TestService : ITestService {}\n    }\n    // 文件夹：Controller/Test/V2.0\n    namespace Api.Test.V2_0 {\n    \tusing JW.Buss.Interface.Test.V2_0;\n    \t[Route(\"api/[controller]\")]\n    \t[ApiVersion(\"2.0\")]\n    \tpublic class TestController {\n    \t\tprivate readonly ITestService _testService;\n    \t\t// private readonly Buss.Interface.Test.V2_0.ITestService _test;\n    \t\tpublic TestController(ITestService testService) {\n    \t\t// public TestController(Buss.Interface.Test.V2_0.ITestServicetestService) {\n    \t\t\t_testService= testService;\n    \t\t}\n    \t}\n    }\n    ```\n\n# 注释规范\n\n### 1、文件头部注释\n\n- 规则\n    1. 文件都包含文件头，要说明文件名、作者、创建时间、变更记录\n\n### 2、类、属性、函数体注释\n\n- 规则\n    1. 使用“`///`”三斜线注释\n    2. 应尽量说明问题\n\n### 3、缩写规范\n\n- 规则\n    1. 标识符应当直观可望文知意，不提倡使用任何缩写\n    2. 字符串变量推荐是用“`str`”或“`s`”开头，采用string.Empty来初始化。\n    3. 普通对象可以以“obj”开头。\n    4. 缩写可自行定义，一般取单词的前/后字符组成，以含义直观为准则。\n    5. 一般情况下不要让缩写破坏标识符的含义。\n\n### 4、排版\n\n- 规则\n    1. 每行语句至少占一行，如果语句过长（超过一屏），应不超过100字符，则该语句断为两行显示。\n    2. 把相似的内容放在一起，比如字段、属性、方法、事件等，使用“#region--#endregion”命令分组。\n    3. 多个程序元素进行对等操作时， 操作符之前、之后或者前后都要加空格。\n    4. 每个方法的源程序行数原则上应该少于200行。(如果超过过多，则需要另写一方法)\n    5. 语句嵌套层次不得超过3层。\n    6. 避免相同的代码段在多个地方出现。(尽量避免代码重复，能复用则复用)\n    7. 函数与函数之间的空行必须**1**行\n\n### 5、语句结构\n\n- 规则\n    1. 如果使用了异常结构，一定要处理异常， 一般是要写日志文件。\n    2. 分支语句不应该使用复杂长条件， 应该将长条件封装成方法。\n    3. switch语句，case后面必须接break或者return\n    4. 禁止使用goto语句进行跳转。\n    5. 行文中严禁出现“魔数”，特定含义的常数必须定义成枚举或常量。\n    6. 不同类型的操作符混合使用时，使用括号给出优先级。\n    7. 不允许使用复杂的操作符组合等。\n    8. 循环、判断语句的程序块部分用花括号括起来， 即使只有一条语句。\n    9. 在switch语句中总是要有default字句，建议使用断言。\n    10. 每个类和方法完成单一的功能，不设计多用途面面俱到的类或方法。\n    11. 严禁使用未经初始化的变量，变量通常使用构造方法来初始。\n\n### 6、代码缩进\n\n- 规则\n    1. 不允许使用Java中的括号换行规范\n    2. 使用**4**个空格来表示缩进\n    3. 花括号\n        1. 类的自动属性花括号与代码合占一行，例`public string Name {get;set;}`\n        2. 左花括号 “{” 放于关键字或方法名同一行\n\n        ```csharp\n        public class Test {\n        \tpublic static void Main(string[] args) {\n        \t\tif(valid) {\n        \t\t\t\t// if valid\n        \t\t} else {\n        \t\t\t\t// not valid\n        \t\t}\n        \t\t\n        \t\twhile(1){\n        \t\t\t\t// do something\n        \t\t}\n        \t}\n        }\n        ```\n\n### 7、大小写\n\n- 规则\n    1. 不要创建名称相同，但大小写区别的任何元素。\n    2. 应当大写仅有两个字符的缩写。(如果只有两个字符，则都大写)\n    3. 不要把易混淆的数字和字符放在一起。\n    4. 使用英文命名标识符。\n\n### 8、重名规范\n\n- 规则\n    1. 不允许变量名、类名、属性名、 方法名等与系统标识符重名\n\n### 9、SQL编码规范\n\n- 规则\n    1. SQL语句全部大写\n    2. 对较为复杂的SQL语句加上注释，说明其功能。\n    3. 连接符OR、IN、AND、以及=、<=、>=等前后加空格。\n    4. 使用明确的列代替 SELECT *。\n    5. 表名必须以“`t_`”开头\n    6. 视图必须以“`v_`”开头\n\n### 10、软件架构\n\n- 规则\n    1. 数据库中每一张表对应一个实体类（Entity）\n    2. 实体类名称使用表名，必须带有`Entity`后缀。\n    3. 数据传输对象，必须带有`Dto`后缀\n    4. 服务接口，必须带有`Service`后缀\n\n# 附表\n\n[表1 各种类型命名规范](https://www.notion.so/f12ab500b3c8451a9a98ede58dd21da5)\n\n[表2 数据类型缩规范](https://www.notion.so/5b1458274025498db44bd2b7e6a23560)","tags":["开发规范","C#"],"categories":["学习"]},{"title":"SQL代码美化工具","url":"/posts/3930d473/","content":"\n# Sql代码美化工具：Sql Pretty Printer for SSMS V3.6.1\n\n![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/SQLPrettyPrinter01.png)\n\nSql Pretty Printer 这个软件主要是sql 语句进行格式化的工具，用起来很顺畅，推荐各位程序员使用。\n\n[官方下载地址](http://www.dpriver.com/dlaction.php)\n\n[在线版本](http://www.dpriver.com/pp/sqlformat.htm) - 不支持中文\n\n[获取免费的证书](http://www.dpriver.com/products/sqlpp/getforfree.php)\n\n# 软件介绍\n\nSQL Pretty Printer 是一款非常实用的SQL代码美化工具，可以把原本杂乱无章的SQL语句用结构化的方式重新展现，使SQL语句更加易于理解和维护。\n\nSQL Pretty Printe 代码格式化工具，拥有超过 60格式选项 ，让您自定义自己最喜爱的SQL布局。严谨的格式化和着色，可以提高SQL的可读性 ，它会让你看起来更专业SQL脚本（在HTML或RTF）在网络上，博客，论坛，文章等！\n\n这个程序用来帮助数据库管理员，开发人员格式化SQL语句，提高SQL语句的可读性,代码高亮。支持输出各种语言格式...如：HTML,VB,Java等多种语言。并且支持CMD命令操作其他程序调用更加方便！\n\nSQL Pretty Printer目前提供4种使用方式，桌面版本，SSMS(SQL Server ManagementStudio)插件，VS插件，和提供API接口。","tags":["工具","SQL","美化"],"categories":["工具"]},{"title":"k8s开环境搭建","url":"/posts/8407d35b/","content":"\n# 前言\n\n> 准备工作\n\n- 安装 [chocolatey](https://chocolatey.org/)\n- 安装 [Helm](https://github.com/helm/helm/releases)\n- 安装 [Docker](https://xiodra.tk/posts/d8072310/)\n\n# 安装`MiniKube`\n\n> 使用`choco`命令安装\n\n``` bash\nchoco install minikube\n```\n\n# 启动集群\n\n***<font color=red> PS:<br>1. DOCKER主机必须2cpu 2Gmemory以上配置<br>2. 启动集群失败必须先minikube delete后重新启动<br>3. 基于Docker时，失败后先docker-machine restart，未验证<br>4. 启动集群必须加--image-mirror-country=cn </font>***\n\n> 基于Docker启动集群\n\n- 基于Docker驱动启动单机k8s集群\n\n``` bash\nminikube start --driver=docker --memory=2048mb --cpus=2 --cache-images=true --image-mirror-country=cn\n```\n\n> 基于VMware启动集群\n\n- 下载驱动，并将驱动复制`C:/Windows/System32/`目录下\n\n[docker-machine-driver-vmware](https://github.com//machine-drivers/docker-machine-driver-vmware)\n\n- 基于VMware启动集群\n\n``` bash\nminikube start --driver=vmware\n```\n\n- 配置本地Docker\n  \n``` bash\nminikube start --driver=vmware --insecure-registry='192.168.126.\n131:2376' --memory=2048mb --cpus=2 --cache-images=true --image-mirror-country=cn\n```\n\n# 安装启用`ingress`\n\n> `minikube`\n\n``` bash\nminikube addons enable ingress\n```\n\n***<font color=red> PS:<br>1. 插件方式未成功</font>***\n\n> 脚本安装\n\n1. 下载文件\n\n[mandatory.yaml](https://github.com/kubernetes/ingress-nginx/blob/nginx-0.30.0/deploy/static/mandatory.yaml)\n\n[service-nodeport.yaml](https://github.com/kubernetes/ingress-nginx/blob/nginx-0.30.0/deploy/baremetal/service-nodeport.yaml)\n\n2. 下载镜像\n\n> 镜像在`mandatory.yaml`文件中查看\n\n``` bash\ndocker pull quay.io/kubernetes-ingress-controller/nginx-ingress-controller:0.30.0\n```\n\n1. 安装\n\n``` bash\nkubectl apply -f mandatory.yaml\nkubectl apply -f service-nodeport.yaml\n```\n\n4. 验证\n\n``` bash\nkubectl get pods --all-namespaces -l app.kubernetes.io/name=ingress-nginx --watch\n```\n\n# 安装`Dapr`\n\n1. 添加和更新repo\n\n``` bash\nhelm repo add dapr https://dapr.github.io/helm-charts/\nhelm repo update\n# See which chart versions are available\nhelm search repo dapr --devel --versions\n```\n\n2. 安装Dapr\n\n``` bash\nhelm upgrade --install dapr dapr/dapr \\\n--version=1.0.0 \\\n--namespace dapr-system \\\n--create-namespace \\\n--wait\n```\n\n3. 验证\n\n``` bash\nkubectl get pods --namespace dapr-system\n```\n\n4. 卸载\n\n``` bash\nhelm uninstall dapr --namespace dapr-system\n```\n\n5. 更新\n\n``` bash\nhelm repo update\nhelm upgrade dapr dapr/dapr --version [NEW VERSION] --namespace dapr-system --wait\n# Ensure all pods are running\nkubectl get pods -n dapr-system -w\n# Restart your application deployments to update the Dapr runtime\nkubectl rollout restart deploy/<DEPLOYMENT-NAME>\n```","tags":["安装","k8s"],"categories":["学习"]},{"title":"Docker for Windows 使用 VMware Workstation","url":"/posts/d8072310/","content":"# 前言\n\n**Docker for Windows** 不同于 **Docker Toolbox**。**Docker for Windows** 对系统的要求至少为**Windows 10** `专业版`，因为它需要**Hyper-V**的支持，而**Dockbox Toolbox**使用**Oracle Virtual Box**而不是**Hyper-V**。使用过**VMware WorkStation**的朋友应该知道，vm无法与**hyper-v**共存。那么如果我的电脑已经安装和使用VM，如何才能使用**Docker for Windows**呢，请看下面的讲解。\n\n# 工作环境\n\n- 操作系统：**Window 10 企业版 LTSC**\n- VMWare：**VMware® Workstation 14 Pro**\n\n# 安装Docker for Windows\n\n从这个地址下载并进行安装：[下载地址](https://download.docker.com/win/stable/Docker%20for%20Windows%20Installer.exe)\n\n安装过程很简单，在此我就不赘述了。\n\n# 安装以后的准备\n\n安装完成以后，Docker for Windows 会自动运行，此时会出现提示没有启用Hyper-V，这里点击canel即可。\n\n![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/HyperV.png)\n\n# 准备工作\n\n## 下载**boot2docker.iso**\n\n从这个地址下载: [下载地址](https://github.com/boot2docker/boot2docker/releases)\n\n然后将 **boot2docker.iso** 放在 C:\\Users\\<用户名>\\.docker\\machine\\cache\\，文件夹不存在就自己建立。\n![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/DockerDev.png)\n\n## 下载 **VMware Workstation** 驱动\n\n从这里下载 [下载地址](https://github.com/pecigonzalo/docker-machine-vmwareworkstation/releases/) 最新版的vm驱动。此驱动非官方开发，但是也在官方的文档中有链接。\n\n然后将 **docker-machine-driver-vmwareworkstation.exe** 复制到 **C:\\Program Files\\Docker\\Docker\\resources\\bin** 下：\n\n![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/VMDriver.png)\n\n# 安装**Docker Machine**\n\n## 打开**VMware Workstation**\n\n这一步是必须的！VM版本必须大于10。\n\n## 安装`dev`示例\n\n打开cmd，执行命令\n\n`docker-machine create --driver=vmwareworkstation dev`\n\n验证安装，执行命令\n\n`docker-machine ls`\n\n![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/DockerInstall.png)\n\n## 激活实例\n\n执行命令：\n\n`docker-machine env dev`\n\n会出现如下图：\n\n![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/DockerEnv.png)\n\n## 设置环境变量\n\n打开环境变量设置，对于上步中的提示设置系统环境变量：\n\n![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/SystemEnv.png)\n\n# 验证是否安装成功\n\n使用命令登录\n\n`docker-machine ssh dev`\n\n出现如下图表示安装成功\n\n![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/DockerSuccess.png)\n\n# 配置加速器\n\n通过命令登录docker-machine\n\n新建文件 `vi /etc/docker/daemon.json`\n\n输入以下内容\n\n```\n{\n  \"registry-mirrors\": [\"https://registry.docker-cn.com\"]\n}\n```\n保存，重启即可\n\n# 容器之内网独立IP访问\n\n通过执行命令`docker-machine ls`找到docker容器宿主机的ip地址`192.168.17.130`\n\n![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/Docker-IP.png)\n\n进入某个Docker容器，执行命令`cat /etc/hosts`查看容器ip地址`172.17.0.3`\n\n![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/Docker-Container-IP.png)\n\n在物理机上以管理员原打开命令行，执行命令`route -p add 172.17.0.0 mask 255.255.255.0 192.168.17.130`，通过`route print 172.17.0.0`查看，效果如图\n\n![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/Route.png)\n\n表示网段 **172.17.0.0** 的网段都经过 **192.168.17.130** 这个网关做路由，实现容器之内网独立IP访问。\n\n如 **mongo** 容器为例：\n\n![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/Mongo.png)\n\n# 收尾工作\n\n因为我们使用的VM，所以我们在使用docker的时候，必须保证vm的dev示例是在运行的。\n\n配置dev开机后天启动\n\n新建一个 **docker_dev_run.bat **的文件，然后用编辑器打开，写下`\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun.exe\" start \"C:\\Users\\Xiodra\\.docker\\machine\\machines\\dev\\dev.vmx\" nogui`这行开启脚本。\n\n**<p style=\"color:red\">注：start前面部分是你VMware的安装路径，后面到nogui部分是你Linux系统文件路径。</p>**\n\n![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/VM.png)\n\n![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/dev.png)\n\n然后，我们再建一个 docker_dev_stop.bat 的文件，写下 `\"C:\\Program Files (x86)\\VMware\\VMware Workstation\\vmrun.exe\" stop \"C:\\Users\\Xiodra\\.docker\\machine\\machines\\dev\\dev.vmx\" soft` 脚本,路径和刚才的一样。\n\n接下来，我们就可以往Windows的 **脚本(登录/注销)** 添加了，`运行 > gpedit.msc > 用户配置 > windows设置 > 脚本(登录/注销) `\n\n![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/Login.png)\n\n![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/Logout.png)\n\n此方法目前有个缺点，就是无法使用**Docker for Windows**的UI管理功能，但是这并不影响，通过命令我们可以完成所有的事情，所以我们在服务中，停止**Docker Desktop Service**，并且将其设为手动启动，避免每次开机就收到一个提示框。\n","tags":["Docker","安装"],"categories":["学习"]},{"title":"CSS模块化","url":"/posts/30f4ba73/","content":"# CSS module\n\nCSS 是前端领域中进化最慢的一块。由于 ES2015/2016 的快速普及和 Babel/Webpack 等工具的迅猛发展，CSS 被远远甩在了后面，逐渐成为大型项目工程化的痛点。也变成了前端走向彻底模块化前必须解决的难题。\n\nCSS 模块化的解决方案有很多，但主要有两类。一类是彻底抛弃 CSS，使用 JS 或 JSON 来写样式。[Radium](https://github.com/FormidableLabs/radium)，[jsxstyle](https://github.com/jsxstyle/jsxstyle)，[react-style](https://github.com/js-next/react-style) 属于这一类。优点是能给 CSS 提供 JS 同样强大的模块化能力；缺点是不能利用成熟的 CSS 预处理器（或后处理器） Sass/Less/PostCSS，`:hover` 和 `:active` 伪类处理起来复杂。另一类是依旧使用 CSS，但使用 JS 来管理样式依赖，代表是 [CSS Modules](https://github.com/css-modules/css-modules)。CSS Modules 能最大化地结合现有 CSS 生态和 JS 模块化能力，API 简洁到几乎零学习成本。发布时依旧编译出单独的 JS 和 CSS。它并不依赖于 React，只要你使用 Webpack，可以在 Vue/Angular/jQuery 中使用。\n\n## CSS 模块化遇到了哪些问题？\n\nCSS 模块化重要的是要解决好两个问题：CSS 样式的导入和导出。灵活按需导入以便复用代码；导出时要能够隐藏内部作用域，以免造成全局污染。Sass/Less/PostCSS 等前仆后继试图解决 CSS 编程能力弱的问题，结果它们做的也确实优秀，但这并没有解决模块化最重要的问题。Facebook 工程师 Vjeux 首先抛出了 React 开发中遇到的一系列 CSS 相关问题。总结如下：\n\n- 1、全局污染\n  \n  CSS 使用全局选择器机制来设置样式，优点是方便重写样式。缺点是所有的样式都是全局生效，样式可能被错误覆盖，因此产生了非常丑陋的 !important，甚至 inline !important 和复杂的选择器权重计数表，提高犯错概率和使用成本。Web Components 标准中的 Shadow DOM 能彻底解决这个问题，但它的做法有点极端，样式彻底局部化，造成外部无法重写样式，损失了灵活性。\n\n- 2、命名混乱\n\n  由于全局污染的问题，多人协同开发时为了避免样式冲突，选择器越来越复杂，容易形成不同的命名风格，很难统一。样式变多后，命名将更加混乱。\n\n- 3、依赖管理不彻底\n  \n  组件应该相互独立，引入一个组件时，应该只引入它所需要的 CSS 样式。但现在的做法是除了要引入 JS，还要再引入它的 CSS，而且 Saas/Less 很难实现对每个组件都编译出单独的 CSS，引入所有模块的 CSS 又造成浪费。JS 的模块化已经非常成熟，如果能让 JS 来管理 CSS 依赖是很好的解决办法。Webpack 的 css-loader 提供了这种能力。\n\n- 4、无法共享变量\n  \n  复杂组件要使用 JS 和 CSS 来共同处理样式，就会造成有些变量在 JS 和 CSS 中冗余，Sass/PostCSS/CSS 等都不提供跨 JS 和 CSS 共享变量这种能力。\n\n- 5、代码压缩不彻底\n  \n  由于移动端网络的不确定性，现在对 CSS 压缩已经到了变态的程度。很多压缩工具为了节省一个字节会把 '16px' 转成 '1pc'。但对非常长的 class 名却无能为力，力没有用到刀刃上。\n\n上面的问题如果只凭 CSS 自身是无法解决的，如果是通过 JS 来管理 CSS 就很好解决，因此 Vjuex 给出的解决方案是完全的 CSS in JS，但这相当于完全抛弃 CSS，在 JS 中以 Object 语法来写 CSS，估计刚看到的小伙伴都受惊了。直到出现了 CSS Modules。\n\n## CSS Modules 模块化方案\n\n![](https://camo.githubusercontent.com/544dc8b41d251cb302c9ebe2f324defd0ec89e02/68747470733a2f2f696d672e616c6963646e2e636f6d2f7470732f69322f5442315968782e4c7058585858616261585858386f462e5f5658582d3830302d3237342e706e67)\n\nCSS Modules 内部通过 [ICSS](https://github.com/css-modules/icss) 来解决样式导入和导出这两个问题。分别对应 :import 和 :export 两个新增的伪类\n\n```\n:import(\"path/to/dep.css\") {\n  localAlias: keyFromDep;\n  /* ... */\n}\n:export {\n  exportedKey: exportedValue;\n  /* ... */\n}\n```\n\n但直接使用这两个关键字编程太麻烦，实际项目中很少会直接使用它们，我们需要的是用 JS 来管理 CSS 的能力。结合 Webpack 的 `css-loader` 后，就可以在 CSS 中定义样式，在 JS 中导入。\n\n##  启用 CSS Modules\n\n```\n// webpack.config.js\ncss?modules&localIdentName=[name]__[local]-[hash:base64:5]\n```\n\n加上 `modules` 即为启用，`localIdentName` 是设置生成样式的命名规则。\n\n```\n/* components/Button.css */\n.normal { /* normal 相关的所有样式 */ }\n.disabled { /* disabled 相关的所有样式 */ }\n```\n\n```\n/* components/Button.js */\nimport styles from './Button.css';\n\nconsole.log(styles);\n\nbuttonElem.outerHTML = `<button class=${styles.normal}>Submit</button>`\n```\n\n生成的 HTML 是\n\n```\n<button class=\"button--normal-abc53\">Submit</button>\n```\n\n注意到 `button--normal-abc53` 是 CSS Modules 按照 `localIdentName` 自动生成的 class 名。其中的 `abc53` 是按照给定算法生成的序列码。经过这样混淆处理后，class 名基本就是唯一的，大大降低了项目中样式覆盖的几率。同时在生产环境下修改规则，生成更短的 class 名，可以提高 CSS 的压缩率。\n\n上例中 console 打印的结果是：\n\n```\nObject {\n  normal: 'button--normal-abc53',\n  disabled: 'button--disabled-def884',\n}\n```\n\nCSS Modules 对 CSS 中的 class 名都做了处理，使用对象来保存原 class 和混淆后 class 的对应关系。\n\n通过这些简单的处理，CSS Modules 实现了以下几点：\n\n- 所有样式都是 local 的，解决了命名冲突和全局污染问题\n- class 名生成规则配置灵活，可以此来压缩 class 名\n- 只需引用组件的 JS 就能搞定组件所有的 JS 和 CSS\n- 依然是 CSS，几乎 0 学习成本\n\n##  样式默认局部\n\n使用了 CSS Modules 后，就相当于给每个 class 名外加加了一个 `:local`，以此来实现样式的局部化，如果你想切换到全局模式，使用对应的 `:global`。\n\n```\n.normal {\n  color: green;\n}\n\n/* 以上与下面等价 */\n:local(.normal) {\n  color: green; \n}\n\n/* 定义全局样式 */\n:global(.btn) {\n  color: red;\n}\n\n/* 定义多个全局样式 */\n:global {\n  .link {\n    color: green;\n  }\n  .box {\n    color: yellow;\n  }\n}\n```\n\n##  Compose 来组合样式\n\n对于样式复用，CSS Modules 只提供了唯一的方式来处理 `:composes` 组合\n\n```\n/* components/Button.css */\n.base { /* 所有通用的样式 */ }\n\n.normal {\n  composes: base;\n  /* normal 其它样式 */\n}\n\n.disabled {\n  composes: base;\n  /* disabled 其它样式 */\n}\n```\n\n```\nimport styles from './Button.css';\n\nbuttonElem.outerHTML = `<button class=${styles.normal}>Submit</button>`\n```\n\n生成的 HTML 变为\n\n```\n<button class=\"button--base-daf62 button--normal-abc53\">Submit</button>\n```\n\n由于在 `.normal` 中 composes 了 `.base`，编译后会 normal 会变成两个 class。\n\n```\n/* settings.css */\n.primary-color {\n  color: #f40;\n}\n\n/* components/Button.css */\n.base { /* 所有通用的样式 */ }\n\n.primary {\n  composes: base;\n  composes: primary-color from './settings.css';\n  /* primary 其它样式 */\n}\n```\n\n对于大多数项目，有了 `composes` 后已经不再需要 Sass/Less/PostCSS。但如果你想用的话，由于 `composes` 不是标准的 CSS 语法，编译时会报错。就只能使用预处理器自己的语法来做样式复用了。\n\n##  class 命名技巧\n\nCSS Modules 的命名规范是从 `BEM` 扩展而来。`BEM` 把样式名分为 3 个级别，分别是：\n\n- Block：对应模块名，如 Dialog\n- Element：对应模块中的节点名 Confirm Button\n- Modifier：对应节点相关的状态，如 disabled、highlight\n\n综上，BEM 最终得到的 class 名为 `dialog__confirm-button--highlight`。使用双符号 `__` 和 `--` 是为了和区块内单词间的分隔符区分开来。虽然看起来有点奇怪，但 BEM 被非常多的大型项目和团队采用。我们实践下来也很认可这种命名方法。\n\nCSS Modules 中 CSS 文件名恰好对应 Block 名，只需要再考虑 Element 和 Modifier。BEM 对应到 CSS Modules 的做法是：\n\n```\n/* .dialog.css */\n.ConfirmButton--disabled {\n}\n```\n\n你也可以不遵循完整的命名规范，使用 camelCase 的写法把 Block 和 Modifier 放到一起：\n\n```\n/* .dialog.css */\n.disabledConfirmButton {\n}\n```\n\n##  如何实现CSS，JS变量共享\n\n> 注：CSS Modules 中没有变量的概念，这里的 CSS 变量指的是 Sass 中的变量。\n\n上面提到的 `:export` 关键字可以把 CSS 中的 变量输出到 JS 中。下面演示如何在 JS 中读取 Sass 变量：\n\n```\n/* config.scss */\n$primary-color: #f40;\n\n:export {\n  primaryColor: $primary-color;\n}\n```\n\n```\n/* app.js */\nimport style from 'config.scss';\n\n// 会输出 #F40\nconsole.log(style.primaryColor);\n```\n\n##  CSS Modules 使用技巧\n\nCSS Modules 是对现有的 CSS 做减法。为了追求**简单可控**，作者建议遵循如下原则：\n\n- 不使用选择器，只使用 class 名来定义样式\n- 不层叠多个 class，只使用一个 class 把所有样式定义好\n- 所有样式通过 composes 组合来实现复用\n- 不嵌套\n\n上面两条原则相当于削弱了样式中最灵活的部分，初使用者很难接受。第一条实践起来难度不大，但第二条如果模块状态过多时，class 数量将成倍上升。\n\n一定要知道，上面之所以称为建议，是因为 CSS Modules 并不强制你一定要这么做。听起来有些矛盾，由于多数 CSS 项目存在深厚的历史遗留问题，过多的限制就意味着增加迁移成本和与外部合作的成本。初期使用中肯定需要一些折衷。幸运的是，CSS Modules 这点做的很好：\n\n**如果我对一个元素使用多个 class 呢？**\n\n没问题，样式照样生效。\n\n**如何我在一个 style 文件中使用同名 class 呢？**\n\n没问题，这些同名 class 编译后虽然可能是随机码，但仍是同名的。\n\n**如果我在 style 文件中使用伪类，标签选择器等呢？**\n\n没问题，所有这些选择器将不被转换，原封不动的出现在编译后的 css 中。也就是说 CSS Modules 只会转换 class 名和 id 选择器名相关的样式。\n\n但注意，上面 3 个“如果”尽量不要发生。\n\n##  CSS Modules 结合 React 实践\n\n在 `className` 处直接使用 css 中 `class` 名即可。\n\n```\n/* dialog.css */\n.root {}\n.confirm {}\n.disabledConfirm {}\n```\n\n```\nimport classNames from 'classnames';\nimport styles from './dialog.css';\n\nexport default class Dialog extends React.Component {\n  render() {\n    const cx = classNames({\n      [styles.confirm]: !this.state.disabled,\n      [styles.disabledConfirm]: this.state.disabled\n    });\n\n    return <div className={styles.root}>\n      <a className={cx}>Confirm</a>\n      ...\n    </div>\n  }\n}\n```\n\n注意，一般把组件最外层节点对应的 class 名称为 `root`。这里使用了 [classnames](https://www.npmjs.com/package/classnames) 库来操作 `class` 名。\n如果你不想频繁的输入 `styles.**`，可以试一下 [react-css-modules](https://github.com/gajus/react-css-modules)，它通过高阶函数的形式来避免重复输入 `styles.**`。\n\n##  CSS Modules 结合历史遗留项目实践\n\n好的技术方案除了功能强大炫酷，还要能做到现有项目能平滑迁移。CSS Modules 在这一点上表现的非常灵活。\n\n##  外部如何覆盖局部样式\n\n当生成混淆的 class 名后，可以解决命名冲突，但因为无法预知最终 class 名，不能通过一般选择器覆盖。我们现在项目中的实践是可以给组件关键节点加上 data-role 属性，然后通过属性选择器来覆盖样式。\n\n如\n\n```\n// dialog.js\n  return <div className={styles.root} data-role='dialog-root'>\n      <a className={styles.disabledConfirm} data-role='dialog-confirm-btn'>Confirm</a>\n      ...\n  </div>\n```\n\n```\n// dialog.css\n[data-role=\"dialog-root\"] {\n  // override style\n}\n```\n\n因为 CSS Modules 只会转变类选择器，所以这里的属性选择器不需要添加 `:global`。\n\n##  如何与全局样式共存\n\n前端项目不可避免会引入 normalize.css 或其它一类全局 css 文件。使用 Webpack 可以让全局样式和 CSS Modules 的局部样式和谐共存。\n\n```\n// webpack.config.js\nmodule: {\n  loaders: [{\n    test: /\\.jsx?$/,\n    loader: 'babel'\n  }, {\n    test: /\\.scss$/,\n    exclude: path.resolve(__dirname, 'src/styles'),\n    loader: 'style!css?modules&localIdentName=[name]__[local]!sass?sourceMap=true'\n  }, {\n    test: /\\.scss$/,\n    include: path.resolve(__dirname, 'src/styles'),\n    loader: 'style!css!sass?sourceMap=true'\n  }]\n}\n```\n\n```\n/* src/app.js */\nimport './styles/app.scss';\nimport Component from './view/Component'\n\n/* src/views/Component.js */\n// 以下为组件相关样式\nimport './Component.scss';\n```\n\n目录结构如下：\n\n```\nsrc\n├── app.js\n├── styles\n│   ├── app.scss\n│   └── normalize.scss\n└── views\n    ├── Component.js\n    └── Component.scss\n```\n\n这样所有全局的样式都放到 `src/styles/app.scss` 中引入就可以了。其它所有目录包括 `src/views` 中的样式都是局部的。\n\n##  总结\n\nCSS Modules 很好的解决了 CSS 目前面临的模块化难题。支持与 Sass/Less/PostCSS 等搭配使用，能充分利用现有技术积累。同时也能和全局样式灵活搭配，便于项目中逐步迁移至 CSS Modules。CSS Modules 的实现也属轻量级，未来有标准解决方案后可以低成本迁移。\n\n> 引用：https://github.com/camsong/blog/issues/5\n\n- [CSS module用法教程](http://www.ruanyifeng.com/blog/2016/06/css_modules.html)","tags":["CSS","前端"],"categories":["学习"]},{"title":"如何发布NPM模块（typescript）","url":"/posts/4512cdc4/","content":"# 1. 如何发布模块（typescript）\n\n## 1.1. 准备\n\n需要准备[Github](https://github.com/)和[NPM](https://www.npmjs.com/)账户\n\n## 1.2. 开始\n\n### 1.2.1. 合理的`package.json`\n```\n{\n  \"name\": \"full-sample\",\n  \"version\": \"0.1.0\",\n  \"description\": \"A sample to learn NPM.\",\n  \"main\": \"./dist/index.js\",\n  \"scripts\": {\n    \"prepare\": \"npm run rebuild\",\n    \"build\": \"tsc -p .\",\n    \"rebuild\": \"npm run clean && npm run lint && npm run build\",\n    \"test\": \"echo See directory sources/tests\",\n    \"clean\": \"rm -rf dist\",\n    \"lint\": \"tslint --project tslint.json\"\n  },\n  \"keywords\": [\n    \"npm\",\n    \"sample\"\n  ],\n  \"author\": \"NPM Learner <me@sample.com> (https://sample.com/)\",\n  \"license\": \"Apache-2.0\",\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/learn-npm/full-sample.git\"\n  },\n  \"bugs\": {\n    \"url\": \"https://github.com/learn-npm/full-sample/issues\"\n  },\n  \"homepage\": \"https://github.com/learn-npm/full-sample#readme\",\n  \"types\": \"./dist/index.d.ts\",\n  \"typings\": \"./dist/index.d.ts\",\n  \"dependencies\": {\n    \"sequelize\": \"^4.24.0\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^8.0.51\",\n    \"@types/sequelize\": \"^4.0.79\",\n    \"typescript\": \"^2.6.1\"\n  },\n  \"engines\": {\n    \"node\": \">=8.0.0\"\n  }\n}\n```\n### 1.2.2. 下面逐个字段解释\n\n> **homepage**\n\n  指定项目的主页地址，如果没有一般可以使用项目的 GitHub 地址。\n\n> **bugs.url**\n\n  指定项目的 Bug 反馈地址，一般可以用项目的 GitHub Issue 地址。\n\n> **repository.url** 和 **repository.type**\n    \n  指定项目的源码仓库地址，可以指定是 git/cvs/svn。\n\n> **main**\n    \n  指定 Node.js 中 require(“moduel-name”) 导入的默认文件。\n\n> **keywords**\n\n  指定项目的关键词，合理设置有利于让他人发现你的项目。\n\n> **engines**\n    \n  设置项目对引擎的版本要求，比如 node、electron、vscode 等。\n\n> **types** 和 **typings**\n\n  设置项目内置的 TypeScript 模块声明文件入口文件。\n\n### 1.2.3. scripts 字段\n\nscripts 字段作为单独一节解释，因为它是用于构建控制和发布控制的工具。\n\n> **scripts.build**\n    \n  这个允许使用 npm run build 命令直接编译 TS 代码。\n\n> **scripts.lint**\n    \n  这个允许使用 npm run lint 命令调用 TSLinter 对代码进行格式检查。\n\n> **scripts.clean**\n    \n  这个允许使用 npm run clean 命令清理编译结果。\n\n> **scripts.rebuild**\n    \n  这个允许使用 npm run rebuild 命令清理编译结果然后重新生成。\n\n> **scripts.prepare**\n\n  这个不是给我们用的，而是 NPM 提供的钩子，这个命令会在执行 npm publish 的时候被调用。因此可以用这个钩子进行发布前构建。\n\n### 1.2.4. Git设置\n\nGit 应当使用 .gitignore 文件忽略那些编译结果，以及 NPM 依赖的包文件\n```\n/node_modules/\n/dist/\n*.log\n```\n\n### 1.2.5. NPM 包文件设置\n\nNPM 打包发布的时候，会默认把当前目录下所有文件打包。但是 Git 仓库中，有些东西是不需要\n发布到 NPM 的，因此我们需要使用一个文件 `.npmignore` 来忽略这些文件，常用配置如下\n```\n/.git/\n/.vscode/\n/docs/\n/node_modules/\n.gitignore\n.npmignore\ntslint.json\ntsconfig.json\n*.log\n```\n\n### 1.2.6. 配置 tsconfig.json\n前面说了，假定 TypeScript 的代码在 `sources` 目录下，编译的输出目录则为 `dist`。那么需要\n\n在 tsconfig.json 里面通过 `rootDir` 和 `outDir` 选项指定。\n\n其次，为了让其它 TypeScript 程序能正常使用你的包，你还应该设置 `declaration` 字段为\n`true`，使之自动生成 `*.d.ts` 文件。此处我们假定模块的入口是` index.js` ，因此你必须\n实现一个 `index.ts` 文件，作为模块的入口。\n\n另外，如果要实现 TypeScript 源码调试，则需要开启 `sourceMap` 选项，以生成源码映射\n文件。\n\n### 1.2.7 发布\n\n- npm login\n  \n  通过命令`npm login`登陆注册的npm账户，密码及注册邮箱（**邮箱必须通过验证方可发布**）\n  ![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/npm_login.png)\n\n- npm publish\n  \n  需要发布的npm包准备好，测试完毕后可以通过`npm publish`进行发布\n  ![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/npm_publish.png)\n\n## 1.3. 维护\n\n### 1.3.1. 版本号维护\n\n> 正常版本控制\n\n```\nnpm version v0.1.0      # 版本号变成 0.1.0，即显式设置版本号。\nnpm version patch       # 版本号从 0.1.0 变成 0.1.1，即修订版本号加一。\nnpm version minor       # 版本号从 0.1.1 变成 0.2.0，即子版本号加一。\nnpm version major       # 版本号从 0.2.0 变成 1.0.0，即主版本号加一。\n```\n\n> 创建“预发布版本”，也就是非稳定版本\n\n```\nnpm version v1.2.3\n\n# 版本号从 1.2.3 变成 1.2.4-0，就是 1.2.4 版本的第一个预发布版本。\nnpm version prepatch\n\n# 版本号从 1.2.4-0 变成 1.3.0-0，就是 1.3.0 版本的第一个预发布版本。\nnpm version preminor\n\n# 版本号从 1.2.3 变成 2.0.0-0，就是 2.0.0 版本的第一个预发布版本。\nnpm version premajor\n\n# 版本号从 2.0.0-0 变成 2.0.0-1，就是使预发布版本号加一。\nnpm version prerelease\n```\n\n> *注意*\n\nversion 命令默认会给你的 git 仓库自动 commit 一把，并打一个 tag。如果不想它动你的\ngit 仓库，你应该使用 --no-git-tag-version 参数\n\n`npm --no-git-tag-version version patch`\n\n可以使用如下 NPM 设置彻底禁止它\n\n```\nnpm config set git-tag-version false  # 不要自动打 tag\nnpm config set commit-hooks false     # 不要自动 commit\n```\n\n### 1.3.2. 使用标签\n\n以 TypeScript 为例，通过 `npm info typescript` 可以看到 `dist-tags` 字段有着五个\n值，分别是 `latest`, `beta`, `rc`, `next`, `insiders`，这些都是 `dist-tag`，可以\n称之为标签——你可以把它理解为 `git` 里面的分支。\n\n有什么用呢？其实，我们平时用 `npm install xxxxxx` 的时候，是使用了一个潜在的选项\n`tag = latest`，可以通过 `npm config list -l | grep tag` 看到。\n\n因此实际上是执行了 `npm install xxxxxx@latest`。也就是安装了 `latest` 这个标签\n对应的最新版本。\n\n不同的标签可以有不同的版本，这就方便我们发表非稳定版本到 npm 上，与稳定版本分开。\n默认是发布到 `latest` 标签下的。\n\n例如 `npm publish --tag dev` 就可以发布一个版本到 `dev` 标签下。\n","tags":["NPM","Node Module","Typescript"],"categories":["开发"]},{"title":"gulp模块打包","url":"/posts/33105f49/","content":"# 使用Gulp进行模块打包\n\n## 中文技术文档\n\n[gulp-js](https://www.gulpjs.com.cn/)\n\n## 入门指南\n\n> 1、全局安装 gulp：\n\n```\nnpm install --global gulp\n```\n\n> 2、作为项目的开发依赖（**devDependencies**）安装：\n\n```\nnpm install --save-dev gulp\n```\n\n> 3、在项目根目录下创建一个名为 **gulpfile.js** 的文件：\n\n```\nvar gulp = require('gulp');\n\ngulp.task('default', function() {\n  // 将你的默认的任务代码放在这\n});\n```\n\n## 使用typescript语言\n\n> 1、除以上安装模块，还必须在项目的开发依赖（devDependencies）安装：\n\n```\nnpm install --save-dev typescript gulp-typescript ts-node gulpclass\n```\n\n> 2、在项目根目录下创建一个名为 **gulpfile.ts** 的文件：\n\n```\nimport { Gulpclass, Task, SequenceTask, MergedTask } from \"gulpclass\";\n\nconst gulp = require(\"gulp\");\nconst del = require(\"del\");\nconst sourcemaps = require(\"gulp-sourcemaps\");\nconst uglify = require('gulp-uglify');\nconst ts = require(\"gulp-typescript\");\n\n@Gulpclass()\nexport class Gulpfile {\n    @Task()\n    clean(cb: Function) {\n        return del([\"./lib/**\"], cb);\n    }\n\n    /**\n     * Copies all sources to the package directory.\n     */\n    @MergedTask()\n    packageCompile() {\n        const tsProject = ts.createProject(\"tsconfig.json\", { typescript: require(\"typescript\") });\n        const tsResult = gulp.src([\"./src/**/*.ts\", \"./node_modules/@types/**/*.ts\"])\n            .pipe(sourcemaps.init())\n            .pipe(tsProject());\n\n        return [\n            tsResult.dts.pipe(gulp.dest(\"./lib\")),\n            tsResult.js\n                .pipe(uglify())\n                .pipe(sourcemaps.write(\".\", { sourceRoot: \"\", includeContent: true }))\n                .pipe(gulp.dest(\"./lib\"))\n        ];\n    }\n\n    @SequenceTask()\n    package() {\n        return [\n            \"clean\",\n            \"packageCompile\",\n        ];\n    }\n}\n```\n\n> 4、运行，以上面例子，输入下面命令即可运行\n\n```\ngulp package\n```\n\n## 注意\n\n在使用**gulpfile.ts**文件时，必须在项目的开发依赖（devDependencies）中安装**ts-node**模块，运行`gulp`命令时才能找到任务\n\n- 检查方法，在项目目录中输入\n\n  ```\n  gulp -v\n  ```\n  ![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/gulp_version.png)\n\n  显示以上内容及安装正确，如有错误则异常，需检查安装是否正确\n\n- 运行`gulp package`出现`Task 'package' is not in your gulpfile`，则检查gulp的相关依赖\n  \n  ```\n  npm list gulp gulp-typescript gulpclass ts-node\n  ```\n  ![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/typescript%E4%B8%8Bgulp%E4%BE%9D%E8%B5%96%E7%89%88%E6%9C%AC.png)\n","tags":["Gulp","打包"],"categories":["工具"]},{"title":"MongoDB 学习","url":"/posts/5a6465fb/","content":"\n## MongoDB 环境搭建文档说明\n\n#### 1. 安装（ZIP安装）\n\n  [Mongodb 下载中心](https://www.mongodb.com/download-center#community)\n\n  [全版本下载中心](http://dl.mongodb.org/dl/win32/x86_64) \n\n  - 选在下载ZIP文件\n\n  - 将zip文件解压放到盘符的根目录（如C：或D：），为了方便建议文件夹命名尽量简短如（d:\\mongodb）\n\n  - 创建数据库文件的存放位置，比如 ***d:/mongodb/data/db*** 。启动mongodb服务之前需要必须创建数据库文件的存放文件夹，否则命令不会自动创建，而且不能启动成功。\n\n  - 在 **d:\\mongodb\\data** 下新建文件夹 **log** （存放日志文件）并且新建文件 **mongodb.log** ;在 ***d:\\mongodb*** 新建文件**mongo.config**\n\n  - 用记事本打开 **mongo.config** 输入：\n  \n    ```\n    dbpath=D:\\mongodb\\data\\db\n    logpath=D:\\mongodb\\data\\log\\mongo.log \n    ```\n\n  - 用管理员身份打开cmd命令行，进入 ***D:\\mongodb\\bin*** 目录，输入如下的命令：\n  \n    ```\n    mongod --config D:\\mongodb\\mongo.config --install --bind_ip 0.0.0.0 --serviceName \"MongoDB\"\n    ```\n\n    **<font color='red'>PS: `bind_ip` 是4.0以后版本必须添加 `0.0.0.0`，这样远程才能访问该数据库，默认绑定 `127.0.0.1`，仅可本机访问  </font>**\n\n  - 在服务中启动**MongonDB**，默认端口是27017\n\n#### 2. 基本操作\n\n  增、删、查、改\n\n  > 增加\n\n    ```\n    db.表名.insert({'字段名':'内容'});\n    db.表名.save({'字段名':'内容'});\n    ```\n\n  **<font color='red'>PS:_id可以自已插入、一个表中不一定要字段都相同，虽然 insert 和 save 方法都可以插入数据，当默认的“_id”值已存在时，调用insert方法插入会报错；而save方法不会,会更新相同的_id所在行数据的信息。</font>**\n\n  > 查\n\n    ```\n    大于：$gt\n    小于：$lt\n    大于等于：$gte\n    小于等于：$lte\n    非等于：$ne\n    正则表达式\n\n    eg:\n    db.user.find({'age':{'$gt':18}});\n    db.user.find({'age':{'$lt':18}});\n    db.user.find({'age':{'$gte':18}});\n    db.user.find({'age':{'$lte':18}});\n    db.user.find({'age':{'$ne':18}});\n    db.user.find({'name':/燕/})\n    ```\n\n  > 查询第一条\n  \n    ```\n    db.表名.findOne(条件);\n    eg:\n    db.user.findOne({'name':'Tom'})\n    ```\n\n  > 分页查询\n\n    ```\n    db.表名.find(条件).skip(跳过数量).limit(查找数量);\n    eg:\n    db.user.find().skip(0).limit(100);\n    ```\n\n  > 批量操作\n  \n    ```\n    // Example of a simple bulkWrite operation\n\n    var MongoClient = require('mongodb').MongoClient,\n      test = require('assert');\n    MongoClient.connect('mongodb://localhost:27017/test', function(err, db) {\n      // Get the collection\n      var col = db.collection('bulk_write');\n      col.bulkWrite([\n          { insertOne: { document: { a: 1 } } }\n        , { updateOne: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }\n        , { updateMany: { filter: {a:2}, update: {$set: {a:2}}, upsert:true } }\n        , { deleteOne: { filter: {c:1} } }\n        , { deleteMany: { filter: {c:1} } }\n        , { replaceOne: { filter: {c:3}, replacement: {c:4}, upsert:true}}]\n      , {ordered:true, w:1}, function(err, r) {\n        test.equal(null, err);\n        test.equal(1, r.nInserted);\n        test.equal(2, r.nUpserted);\n        test.equal(0, r.nRemoved);\n\n        // Crud fields\n        test.equal(1, r.insertedCount);\n        test.equal(1, Object.keys(r.insertedIds).length);\n        test.equal(1, r.matchedCount);\n        test.ok(r.modifiedCount == 0 || r.modifiedCount == 1);\n        test.equal(0, r.deletedCount);\n        test.equal(2, r.upsertedCount);\n        test.equal(2, Object.keys(r.upsertedIds).length);\n\n        // Ordered bulk operation\n        db.close();\n      });\n    });\n    ```\n\n#### 3. MongoDB导入导出以及数据库备份\n\n  * 1. MongoDB数据导入与导出\n\n    - 1）导出工具：mongoexport\n      - 1、概念：\n          \n          mongoDB中的mongoexport工具可以把一个collection导出成JSON格式或CSV格式的文件。可以通过参数指定导出的数据项，也可以根据指定的条件导出数据。\n\n      - 2、语法：\n\n          `mongoexport -d dbname -c collectionname -o file --type json/csv -f field`\n          \n          >参数说明：\n          >    -d ：数据库名\n          >    -c ：collection名\n          >    -o ：输出的文件名\n          >    --type ： 输出的格式，默认为json\n          >    -f ：输出的字段，如果-type为csv，则需要加上-f \"字段名\"\n\n      - 3、示例：\n          \n          `sudo mongoexport -d mongotest -c users -o /home/python/Desktop/mongoDB/users.json --type json -f  \"_id,user_id,user_name,age,status\"`\n \n    - 2） 数据导入：mongoimport\n\n      - 1、语法：\n          \n          `mongoimport -d dbname -c collectionname --file filename --headerline --type json/csv -f field`\n          \n          >参数说明：\n          \n          >    -d ：数据库名\n          \n          >    -c ：collection名\n          \n          >    --type ：导入的格式默认json\n          \n          >    -f ：导入的字段名\n          \n          >    --headerline ：如果导入的格式是csv，则可以使用第一行的标题作为导入的字段\n          \n          >    --file ：要导入的文件\n  \n      - 2、示例：\n          \n          `sudo mongoimport -d mongotest -c users --file /home/mongodump/articles.json --type json`\n \n  * 2. MongoDB备份与恢复\n\n    - 1）MongoDB数据库备份\n      \n      - 1、语法：\n          \n          `mongodump -h dbhost -d dbname -o dbdirectory`\n          \n          >参数说明：\n          \n          >    -h： MongDB所在服务器地址，例如：127.0.0.1，当然也可以指定端口号：127.0.0.1:27017\n          \n          >    -d： 需要备份的数据库实例，例如：test\n          \n          >    -o： 备份的数据存放位置，例如：/home/mongodump/，当然该目录需要提前建立，这个目录里面存放>该数据库实例的备份数据。\n      \n      - 2、实例：\n        \n        ```\n        sudo rm -rf /home/momgodump/\n        sudo mkdir -p /home/momgodump\n        sudo mongodump -h 192.168.17.129:27017 -d itcast -o /home/mongodump/\n        ```\n          \n  - 2）MongoDB数据库恢复\n      \n    - 1、语法：\n        \n      `mongorestore -h dbhost -d dbname --dir dbdirectory`\n\n      >参数或名：\n      \n      >    -h： MongoDB所在服务器地址\n      \n      >    -d： 需要恢复的数据库实例，例如：test，当然这个名称也可以和备份时候的不一样，比如test2\n      \n      >    --dir： 备份数据所在位置，例如：/home/mongodump/itcast/\n      \n      >    --drop： 恢复的时候，先删除当前数据，然后恢复备份的数据。就是说，恢复后，备份后添加修改的数据都会被删除，慎用！\n    \n    - 2、实例：\n      \n      `mongorestore -h 192.168.17.129:27017 -d itcast_restore --dir /home/mongodump/itcast/`\n    \n","tags":["MongoDB"],"categories":["学习"]},{"title":"React-native 学习","url":"/posts/fa532f8b/","content":"\n# 1. React Native \n\n### 1.0.1. [环境搭建](https://reactnative.cn/docs/0.51/getting-started.html)\n  \n  - Python 2.7\n\n  - Java SDK（1.8+）\n\n  - Android SDK\n\n    - 设置\n\n      * Tools/Android SDK Tools\n\n      * Tools/Android SDK Platform-tools\n\n      * Tools/Android SDK Build-tools (23.0.1)（这个必须版本严格匹配23.0.1）\n\n      * Android 6.0 (API 23)/SDK Platform (1)\n\n      * Extras/Android Support Library\n\n      * Extras/Android Support Repository\n\n![](https://cdn.jsdelivr.net/gh/Xiodra/Media/images/AndroidSDK.png)\n\n  - Node.js\n\n    * 镜像切换模块`npm install -g nrm`\n    * 查看当前镜像`nrm list`\n    * 切换镜像`nrm use taobao`\n    * 测速`nrm test`\n\n  - React-Native命令行工具`npm i -g react-native-cli`\n\n### 1.0.2. Hello Word\n\n  - 创建项目`react-native init MyHelloWord`\n    **<font color='red'>PS：等待数（或数十）分钟</font>**\n\n  - 运行packager`react-native start`\n    **<font color='red'>PS：可以用浏览器访问http://localhost:8081/index.bundle?platform=android看看是否可以看到打包后的脚本（看到很长的js代码就对了）</font>**\n\n  - 运行模拟器\n    - 推荐使用BlueStacks不过要小心它推送的广告和垃圾应用。\n    如果有真机，可以不必运行模拟器，要配置好驱动，使得adb devices可以看到对应的设备。\n\n    - Android Virsual Device\n      ``` PowerShell\n      D:\\Android\\sdk\\tools\\emulator.exe -netdelay none -netspeed full -avd Nexus_5X_API_19\n      ```\n      `D:\\Android\\sdk`Android Studio 目录\n      `Nexus_5X_API_19`是我的模拟器的名称，具体名称，可以打开android studio查看\n\n  - Android 运行`react-native run-android`\n    **<font color='red'>保持packager开启，另外打开一个命令行窗口，然后在工程目录下运行</font>**\n\n### 1.0.3. 设备测试\n\n  - [摄像头](https://www.npmjs.com/package/react-native-camera)`react-native-camera`\n    - `npm install react-native-camera`\n    - `react-native link react-native-camera`\n    - 添加权限\n      > ***android***,路径`android/app/src/main/AndroidManifest.xml`\n      ```\n      <uses-permission android:name=\"android.permission.CAMERA\" />\n      <uses-permission android:name=\"android.permission.RECORD_AUDIO\"/>\n      <uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" />\n      <uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" />  \n      <uses-permission android:name=\"android.permission.VIBRATE\" />\n      ```\n      > ***iOS***,待续\n    - **修改部分**\n      > `android/build.gradle`\n      ```\n      buildscript {\n          repositories {\n              jcenter()\n              google()\n          }\n          dependencies {\n              classpath 'com.android.tools.build:gradle:3.1.3'\n          }\n      }\n\n      allprojects {\n          repositories {\n              mavenLocal()\n              jcenter()\n              google()\n              maven {\n                url \"$rootDir/../node_modules/react-native/android\"\n              }\n              maven { url \"https://jitpack.io\" }\n              maven { url \"https://maven.google.com\" }\n              google()\n          }\n      }\n      ```\n      > `android/gradle/wrapper/gradle-wrapper.properties`\n      ```\n      ...\n      distributionUrl=https\\://services.gradle.org/distributions/gradle-4.4-all.zip\n      ```\n      > `android/app/src/build.gradle`\n      ```\n      dependencies {\n          ...\n          compile (project(':react-native-camera')) {\n              exclude group: \"com.android.support\", module: 'support-v4'\n          }\n          compile('com.google.android.gms:play-services-vision:10.2.0') {\n              force = true\n          }\n      }\n      ```\n  **<font color='red'>1、以上步骤后，尝试构建项目`react-native run-android`<br/>2、使用Android Studio打开`android`，构建项目，根据提示解决错误，但警告是由于android api造成异常，等android解决后修复<br>3、最后添加使用相机的代码</font>**\n\n  - [WebView](https://blog.csdn.net/yeputi1015/article/details/70187748)\n\n    根据该篇文章进行测试\n\n### 1.0.4. 问题\n\n  - Andriod SDK 设置要花很长时间\n  - Android SDK Build-tools 必须包含 （***23.0.1***）\n  - `Unable to resolve module some-module from /Users/username/projectname/AwesomeProject/index.js: Invalid directory /Users/node_modules/some-module`\n  \n    根据[Git](https://github.com/facebook/react-native/issues/4968)方法解决\n\n### 1.0.5. 整合ios，android，web（编外）\n\n  * **react-web**，淘宝前端团队开发的一个可以把react-native转换成web的工具, 大体上能实现了移动端的iOS/安卓/移动web这三端的代码共用\n\n  * **react-native-web**，twitter维护，使用`webpack`的灵活配置，实现了`**.web.js`和`Platform.OS==='web'`这样的平台代码，实现三端代码共用\n\n  * **react-web**依赖于**react-native-web**实现，在*github*中*README.md*文件有注明，但是**react-native-web**目前版本是 ***0.8.0***，而**react-web**版本已经更新 ***1.1.3***，不过**react-web**只在中国正式在生成环境运行中。\n\n  * 各种平台存在自己的差异性，不能完全兼容\n\n  * 该要改的还是要改，该要重写的还是要重写\n\n### 1.0.6. End","tags":["安装","React Native"],"categories":["学习"]},{"title":"SS（R）服务器搭建","url":"/posts/30a3e016/","content":"## SS(R) 服务搭建\n\n### 第一种\n\n- Step 1：执行以下命令\n\n  ```\n  yum -y install wget\n  wget --no-check-certificate https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocksR.sh\n  chmod +x shadowsocksR.sh\n  ./shadowsocksR.sh 2>&1 | tee shadowsocksR.log\n  ```\n\n- Step 2: 输入密码\n- Step 3：输入端口\n- Step 4: 设置加密方式\n- Step 5: 协议\n- Step 6：插件\n- Step 7: 重启\n- 卸载`./shadowsocks-go.sh uninstall`\n\n### 第二种\n\n- Step 1：执行以下命令\n```\nyum -y install wget\nwget -N --no-check-certificate https://softs.fun/Bash/ssr.sh && chmod +x ssr.sh && bash ssr.sh\n```\n或者\n```\nyum -y install wget\nwget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssr.sh && chmod +x ssr.sh && bash ssr.sh\n```\n运行`bash ssr.sh`进入快捷管理界面\n\n- Step 2: 按界面指令进行安装\n\n### 一键加速VPS服务器\n\n- Step 1: 执行命令\n```\nyum -y install wget\nwget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.sh\nchmod +x bbr.sh\n./bbr.sh\n```\n- Step 2: 重启\n","tags":["安装","VPS","SSR"],"categories":["工具"]},{"title":"node.js安装","url":"/posts/63a2d85/","content":"### 1. NVM-Windows 安装\n\n  **[下载地址](https://github.com/coreybutler/nvm-windows/releases)**\n\n  * 在官网中下载最新版本的`nvm-noinstall.zip`,并解压至`C:\\dev\\nvm`目录下\n\n  * 以管理员身份打开`C:\\dev\\nvm`目录下的`install.cmd`文件,直接回车即可,然后在`C:\\`目录下会出现`setting.text`文件,把该文件拷贝至`C:\\dev\\nvm`目录,并且将内容改成一下内容保存即可\n\n    ```\n    root: C:\\dev\\nvm \n    path: C:\\dev\\nodejs \n    arch: 64 \n    proxy: none \n    ```\n\n  * 然后我配置环境变量，因为刚刚点击了`install.cmd`的文件，那么会在环境变量的系统变量中，生成两个环境变量：`NVM_HOME` 和 `NVM_SYMLINK` 我们开始修改这两个变量名的变量值：`NVM_HOME`的变量值为：`C:\\dev\\nvm`;`NVM_SYMLINK`的变量值为：`C:\\dev\\nodejs`\n\n  * 我们还会发现，在**Path**中也会自动添加上`C:\\dev\\nvm;`或者是`C:\\dev\\nodejs`，如果有的话，把他们删掉，没有的话更好，我们自己来配置，在Path的最前面输入： `;%NVM_HOME%;%NVM_SYMLINK%;`\n\n  * 打开一个cmd窗口输入命令：`nvm v `，那么我们会看到当前nvm的版本信息。然后我们可以安装nodejs了。\n\n  **<font color='red'>PS&nbsp;以上目录可根据实际情况选择</font>**\n\n### 2. nvm node.js安装\n\n  * 安装node：`nvm install latest`或者`nvm install 8.9.1 (32-bit)`默认**64-bit**\n\n  * 查看node所有版本:`nvm list available`\n\n  * 查看当前系统node版本:`nvm list`\n\n  * 切换版本：`nvm use 8.9.1`","tags":["安装","node.js"],"categories":["工具"]},{"title":"git常用命令说明","url":"/posts/51566bcc/","content":"# Git 命令说明\n\n<!-- TOC -->\n\n- [Git 命令说明](#git-命令说明)\n  - [1. 全局user name 和email设置](#1-全局user-name-和email设置)\n  - [2. 生成SSH密钥](#2-生成ssh密钥)\n  - [`ssh -T git@github.com`](#ssh--t-gitgithubcom)\n  - [3. 如何用命令将本地项目上传到git](#3-如何用命令将本地项目上传到git)\n  - [4. 如何用命令将服务器项目下载到本地](#4-如何用命令将服务器项目下载到本地)\n  - [5. 常用命令](#5-常用命令)\n\n<!-- /TOC -->\n\n---\n\n## 1. 全局user name 和email设置\n\n```\ngit config --global user.name \"xiodra\"\ngit config --global user.email \"y.dragon.hu@hotmail.com\"\n```\n\n或者当前项目目录下\n\n```\ngit config user.name \"xiodra\"\ngit config user.email \"y.dragon.hu@hotmail.com\"\n```\n\n---\n\n## 2. 生成SSH密钥\n\n* 查看ssh\n\n  `cd ~/.ssh`\n\n  如果没有密钥则不会有此文件夹，有则备份删除\n\n* 生成ssh\n\n  `ssh-keygen -t rsa -C \"y.dragon.hu@hotmail.com\"`\n\n  按3个回车，密码为空。最后得到了两个文件：***id_rsa***和***id_rsa.pub***\n\n* 查看ssh-keygen\n\n  `cat ~/.ssh/id_rsa.pub`\n\n* 配置**Github**\n* 连接测试\n\n  `ssh -T git@github.com`\n---\n\n## 3. 如何用命令将本地项目上传到git\n\n* （先进入项目文件夹）通过命令 **git init **把这个目录变成git可以管理的仓库\n\n  `git init`\n\n* 把文件添加到版本库中，使用命令 **git add .**添加到暂存区里面去，不要忘记后面的小数点**“.”**，意为添加文件夹下的所有文件\n\n  `git add .`\n\n* 用命令 **git commit**告诉Git，把文件提交到仓库。引号内为提交说明\n\n  `git commit -m \"first commit\"`\n\n* 关联到远程库\n\n  `git remote add origin 你的远程库地址`\n\n* 获取远程库与本地同步合并**（如果远程库不为空必须做这一步，否则后面的提交会失败）**\n\n  `git pull --rebase origin master`\n\n* 把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。\n\n  ***执行此命令后会要求输入用户名、密码，验证通过后即开始上传***\n\n  `git push -u origin master`\n\n* 状态查询\n\n  `git status`\n\n  ***以上所有操作都是在进入项目文件夹操作***\n\n\n---\n\n## 4. 如何用命令将服务器项目下载到本地\n\n* 使用 **git clone** 命令下载项目\n\n  `git clone -b 分支名 项目git地址`\n\n  或者直接下载master分支\n\n  `git clone 项目git地址`\n\n  或者指定下载目录\n\n  `git clone 项目git地址 \"项目目录\"`\n\n---\n\n## 5. 常用命令\n\n  ```\n  git clone <repository> --recursive 递归的方式克隆整个项目\n  git submodule add <repository> <path> 添加子模块\n  git submodule init 初始化子模块\n  git submodule update 更新子模块\n  git submodule foreach git pull 拉取所有子模块\n  git submodule update --init --recursive 递归的方式克隆子模块项目\n  git checkout . #本地所有修改的。没有的提交的，都返回到原来的状态\n  git stash #把所有没有提交的修改暂存到stash里面。可用git stash pop回复。\n  ```\n\n  以下是添加 *.gitignore* 的步骤\n\n  ```\n  git rm -r --cached .\n  git add .\n  git commit -m '备注'\n  ```","tags":["Git","命令"],"categories":["工具"]}]